{"version":3,"file":"index.b90b66c1.js","sources":["../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js","../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/helpers/styler.js","../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/pointerAction.js","../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/helpers/aria.js","../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/keyboardAction.js","../../../../../../node_modules/.pnpm/svelte-dnd-action@0.9.37_svelte@3.59.2/node_modules/svelte-dnd-action/src/action.js","../../../../../../node_modules/.pnpm/svelte@3.59.2/node_modules/svelte/animate/index.mjs"],"sourcesContent":["/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n *\n * @param {HTMLElement} el\n * @returns\n */\nexport function svelteNodeClone(el) {\n    const cloned = el.cloneNode(true);\n\n    const values = [];\n    const elIsSelect = el.tagName === \"SELECT\";\n    const selects = elIsSelect ? [el] : [...el.querySelectorAll(\"select\")];\n    for (const select of selects) {\n        values.push(select.value);\n    }\n\n    if (selects.length > 0) {\n        const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll(\"select\")];\n        for (let i = 0; i < clonedSelects.length; i++) {\n            const select = clonedSelects[i];\n            const value = values[i];\n            const optionEl = select.querySelector(`option[value=\"${value}\"`);\n            if (optionEl) {\n                optionEl.setAttribute(\"selected\", true);\n            }\n        }\n    }\n\n    const elIsCanvas = el.tagName === \"CANVAS\";\n    const canvases = elIsCanvas ? [el] : [...el.querySelectorAll(\"canvas\")];\n    if (canvases.length > 0) {\n        const clonedCanvases = elIsCanvas ? [cloned] : [...cloned.querySelectorAll(\"canvas\")];\n        for (let i = 0; i < clonedCanvases.length; i++) {\n            const canvas = canvases[i];\n            const clonedCanvas = clonedCanvases[i];\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            clonedCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n        }\n    }\n\n    return cloned;\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\nimport {getFeatureFlag, FEATURE_FLAG_NAMES} from \"../featureFlags\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {\n            draggedEl.style.height = `${newRect.height}px`;\n            draggedEl.style.width = `${newRect.width}px`;\n        }\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\" ||\n                // copying with and height to make up for rect update timing issues in some browsers\n                (getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === \"width\" || s === \"height\"))\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {armWindowScroller, disarmWindowScroller} from \"./helpers/windowScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst DISABLED_OBSERVATION_INTERVAL_MS = 20;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nconst ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = \"data-is-dnd-original-dragged-item\";\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    armWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const setIntervalMs = Math.max(...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs));\n    const observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); //if setintervalms is 0 it goes to 20, otherwise it is max between it and min observation.\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    disarmWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\nfunction findShadowElementIdx(items) {\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const shadowElIdx = findShadowElementIdx(items);\n    const shadowItem = items.splice(shadowElIdx, 1)[0];\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        originZoneItems.splice(originIndex, 0, shadowItem);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    items.splice(shadowElIdx, 1);\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) shadowElIdx = originIndex;\n\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument | Element } */\n        const rootNode = originDropZone.closest(\"dialog\") || originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items, type, centreDraggedOnCursor} = config;\n        draggedElData = items[currentIdx];\n        draggedElType = type;\n        shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);\n\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, shadowElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        registerDropZone(node, newType);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag && !node.closest(`[${ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE}]`)) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        zoneItemTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = config.zoneItemTabIndex;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        zoneItemTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.zoneItemTabIndex = zoneItemTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = config.zoneItemTabIndex;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY, SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    if (shouldIgnoreZone(node)) {\n        return {\n            update: () => {},\n            destroy: () => {}\n        };\n    }\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\n/**\n * If the user marked something in the ancestry of our node as shadow element, we can ignore it\n * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)\n * @param {HTMLElement} node\n * @return {boolean}\n */\nfunction shouldIgnoreZone(node) {\n    return !!node.closest(`[${SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME}=\"true\"]`);\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        zoneItemTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n    if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {\n        throw new Error(`zoneItemTabIndex should be a number but instead it is a ${typeof zoneItemTabIndex}, ${toString(zoneItemTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return (\n        !isNaN(value) &&\n        (function (x) {\n            return (x | 0) === x;\n        })(parseFloat(value))\n    );\n}\n","import { cubicOut } from '../easing/index.mjs';\nimport { is_function } from '../internal/index.mjs';\n\nfunction flip(node, { from, to }, params = {}) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);\n    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);\n    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);\n    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;\n    return {\n        delay,\n        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,\n        easing,\n        css: (t, u) => {\n            const x = u * dx;\n            const y = u * dy;\n            const sx = t + u * from.width / to.width;\n            const sy = t + u * from.height / to.height;\n            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;\n        }\n    };\n}\n\nexport { flip };\n"],"names":["svelteNodeClone","el","cloned","values","elIsSelect","selects","select","clonedSelects","i","value","optionEl","elIsCanvas","canvases","clonedCanvases","canvas","clonedCanvas","TRANSITION_DURATION_SECONDS","trs","property","createDraggedElementFrom","originalElement","positionCenterOnXY","rect","draggedEl","copyStylesFromTo","DRAGGED_ELEMENT_ID","elTopPx","elLeftPx","center","findCenter","moveDraggedElementToWasDroppedState","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","getFeatureFlag","FEATURE_FLAG_NAMES","copyToEl","computedStyle","s","styleDraggable","draggableEl","dragDisabled","hideElement","dragTarget","decorateShadowEl","shadowEl","SHADOW_ELEMENT_ATTRIBUTE_NAME","unDecorateShadowElement","styleActiveDropZones","dropZones","getStyles","getClasses","dz","styles","style","c","styleInactiveDropZones","preventShrinking","originalMinHeight","originalMinWidth","DEFAULT_DROP_ZONE_TYPE","MIN_OBSERVATION_INTERVAL_MS","DISABLED_OBSERVATION_INTERVAL_MS","MIN_MOVEMENT_BEFORE_DRAG_START_PX","DEFAULT_DROP_TARGET_STYLE","ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","isWorkingOnPreviousDrag","finalizingPreviousDrag","unlockOriginDzMinDimensions","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","typeToDropZones","dzToConfig","elToMouseDownListener","registerDropZone","dropZoneEl","type","incrementActiveDropZoneCount","unregisterDropZone","decrementActiveDropZoneCount","watchDraggedElement","armWindowScroller","DRAGGED_ENTERED_EVENT_NAME","handleDraggedEntered","DRAGGED_LEFT_EVENT_NAME","handleDraggedLeft","DRAGGED_OVER_INDEX_EVENT_NAME","handleDraggedIsOverIndex","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","handleDrop","setIntervalMs","observationIntervalMs","observe","unWatchDraggedElement","disarmWindowScroller","unobserve","findShadowElementIdx","items","item","SHADOW_ITEM_MARKER_PROPERTY_NAME","dropFromOthersDisabled","ITEM_ID_KEY","newOriginZoneItems","dispatchConsiderEvent","TRIGGERS","SOURCES","index","isProximityBased","shadowElIdx","shadowItem","theOtherDz","DRAGGED_LEFT_TYPES","originZoneItems","handleMouseMove","finalizeWithinZone","dispatchFinalizeEvent","cleanupPostDrop","animateDraggedToFinalPosition","callback","shadowElRect","getBoundingRectNoTransforms","newTransform","dropAnimationDurationMs","transition","scheduleDZForRemovalAfterDrop","destroy","dndzone","node","options","initialized","config","elToIdx","addMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","removeMaybeListeners","e","handleDragStart","handleMouseDown","currentIdx","rootNode","originDropZoneRoot","centreDraggedOnCursor","SHADOW_PLACEHOLDER_ITEM_ID","keepOriginalElementInDom","configure","newType","morphDisabled","dropTargetStyle","dropTargetClasses","transformDraggedElement","areObjectsShallowEqual","areArraysShallowEqualSameOrder","getConfigProp","propName","idx","newOptions","destroyDz","INSTRUCTION_IDs","ID_TO_INSTRUCTION","ALERT_DIV_ID","alertsDiv","initAriaOnBrowser","id","txt","instructionToHiddenDiv","initAria","isOnServer","destroyAria","_a","div","alertToScreenReader","alertText","isDragging","draggedItemType","focusedDz","focusedDzLabel","focusedItem","focusedItemId","focusedItemLabel","allDragTargets","elToKeyDownListeners","elToFocusListeners","dzToHandles","globalKeyDownHandler","globalClickHandler","handleZoneFocus","newlyFocusedDz","originItems","originItem","originIdx","itemToMove","targetItems","autoAriaDisabled","triggerAllDzsUpdate","update","dispatchConsider","swap","arr","j","handleKeyDown","children","setCurrentFocusedItem","dropTargets","msg","handleClick","focusedItemIdx","zoneTabIndex","zoneItemTabIndex","handles","shouldIgnoreZone","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME","flipDurationMs","rest","itemWithMissingId","toString","isInt","x","flip","from","to","params","transform","ox","oy","dx","dy","delay","duration","d","easing","cubicOut","is_function","t","u","y","sx","sy"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}